; Initial script generated by the Inno Setup Script Wizard.
;
; This script was substantially updated with the release of p3icli v3.3 and
; utilizes features found in Inno Setup v6.04 (or later).

[Setup]
SignTool=SignP3ICLI
AppName=p3icli
AppVersion=3.3
AppVerName=p3icli 3.3
AppPublisherURL=http://p3icli.sourceforge.net/
AppSupportURL=http://p3icli.sourceforge.net/
AppUpdatesURL=http://p3icli.sourceforge.net/
AppPublisher=Clark Morgan
DefaultDirName={autopf32}\p3icli
DefaultGroupName=p3icli
Compression=lzma
SolidCompression=yes
UninstallDisplayIcon={code:exedir}\p3icli.exe

; if over-installing a new version of p3icli, use the same install privs
; during this install as the last install.
UsePreviousPrivileges=yes

; if this is _not_ an over-install, user is offered a choice of
; admin vs. non-admin install.
PrivilegesRequiredOverridesAllowed=dialog

; Next setting forces a reload of env var data in case the
; PATH changed.
ChangesEnvironment=yes

[Tasks]
Name: "desktopicon"; Description: "{cm:CreateDesktopIcon}"; Flags: unchecked

Name: "envPath"; Description: "Add installation folder to PATH variable (highly recommended)"; Check: mustModifyPATH;

[Files]
Source: "..\doc\sampleTemplate.potx"; DestDir: "{app}"; Flags: ignoreversion
Source: "..\doc\portfolio.potx"; DestDir: "{app}"; Flags: ignoreversion
Source: "..\doc\p3icli_help.html"; DestDir: "{app}"; Flags: ignoreversion
Source: "..\doc\sample_template.png"; DestDir: "{app}"; Flags: ignoreversion
Source: "..\doc\sample_named_slide.png"; DestDir: "{app}"; Flags: ignoreversion
Source: "..\doc\sample_web_text.png"; DestDir: "{app}"; Flags: ignoreversion
Source: "..\doc\sample_web_text_office_2010.png"; DestDir: "{app}"; Flags: ignoreversion
Source: "..\doc\sample_web_text_office_2013.png"; DestDir: "{app}"; Flags: ignoreversion
Source: "..\doc\sample_web_text_office_2016_2019.png"; DestDir: "{app}"; Flags: ignoreversion
Source: "..\doc\resized_pic1_demo_slide.png"; DestDir: "{app}"; Flags: ignoreversion
Source: "..\doc\original_resize_demo_slide.png"; DestDir: "{app}"; Flags: ignoreversion
Source: "..\doc\title_and_caption_moved_demo_slide.png"; DestDir: "{app}"; Flags: ignoreversion
Source: "..\doc\task_scheduler_config.png"; DestDir: "{app}"; Flags: ignoreversion
Source: "..\doc\ppt_is_sorry.png"; DestDir: "{app}"; Flags: ignoreversion
Source: "p3icli.exe"; DestDir: "{code:exedir}"; Flags: ignoreversion signonce
Source: "readme.txt"; DestDir: "{app}"; Flags: ignoreversion isreadme
Source: "copying.txt"; DestDir: "{app}"; Flags: ignoreversion
Source: "buglist.txt"; DestDir: "{app}"; Flags: ignoreversion
; NOTE: Don't use "Flags: ignoreversion" on any shared system files

[Icons]
Name: "{group}\PPT Picture Insert CLI"; Filename: "{code:exedir}\p3icli.exe"
Name: "{group}\Documentation"; Filename: "{app}\p3icli_help.html"
Name: "{group}\README"; Filename: "{app}\readme.txt"
Name: "{group}\LICENSE"; Filename: "{app}\copying.txt"
Name: "{group}\Bug List"; Filename: "{app}\buglist.txt"
Name: "{autodesktop}\p3icli"; Filename: "{code:exedir}\p3icli.exe"; Tasks: desktopicon

[Run]
Filename: "{code:exedir}\p3icli.exe"; Description: "{cm:LaunchProgram,p3icli}"; Flags: nowait postinstall skipifsilent unchecked

[Code]
function exedir(Default: String): String;
begin
    if IsAdminInstallMode then
        Result := ExpandConstant('{win}')
    else
        Result := ExpandConstant('{app}');
end;

(* If running a non-Admin install, must modify user's PATH
   env var to point at location of installed program exe.

   For an Admin install, the program exe will be dropped
   in {win}, which is always in the PATH.                  *)
function mustModifyPATH :boolean;
begin
    if IsAdminInstallMode then
        result := false
    else
        result := true;
end;

procedure EnvAddPath(instlPath: string); forward;
procedure EnvRemovePath(instlPath: string); forward;

(* ------------------------------------------------------ *)
(* Next four routines based on code from Wojciech Mleczek *)
(* ------------------------------------------------------ *)

procedure CurStepChanged(CurStep: TSetupStep);
begin
    if mustModifyPath then
    begin
        if (CurStep = ssPostInstall) then
            if WizardIsTaskSelected('envPath') then
                EnvAddPath(ExpandConstant('{app}'));
    end;
end;

procedure CurUninstallStepChanged(CurUninstallStep: TUninstallStep);
begin
    if mustModifyPath then
    begin
        if (CurUninstallStep = usPostUninstall) then
            EnvRemovePath(ExpandConstant('{app}'));
    end;
end;

const EnvironmentKey = 'Environment';

procedure EnvAddPath(instlPath: string);
var
    Paths: string;
    PathsEmpty: boolean;
begin
    PathsEmpty := false;

    { Retrieve current path (use empty string if entry not exists) }
    if not RegQueryStringValue(HKEY_CURRENT_USER, EnvironmentKey, 'Path', Paths) then
        PathsEmpty := true
    else if Paths = '' then
        PathsEmpty := true;

    if PathsEmpty then
        Paths := instlPath + ';'
    else
    begin
        { Skip if string already found in path }
        if Pos(';' + Uppercase(instlPath) + ';',  ';' + Uppercase(Paths) + ';') > 0 then exit;
        if Pos(';' + Uppercase(instlPath) + '\;', ';' + Uppercase(Paths) + ';') > 0 then exit;

        { Append App Install Path to the end of the path variable }
        Log(Format('Right(Paths, 1): [%s]', [Paths[length(Paths)]]));
        if Paths[length(Paths)] = ';' then
            Paths := Paths + instlPath + ';'  { don't double up ';' in env(PATH) }
        else
            Paths := Paths + ';' + instlPath + ';' ;
    end;

    { Overwrite (or create if missing) path environment variable }
    if RegWriteStringValue(HKEY_CURRENT_USER, EnvironmentKey, 'Path', Paths)
    then Log(Format('The [%s] added to PATH: [%s]', [instlPath, Paths]))
    else Log(Format('Error while adding the [%s] to PATH: [%s]', [instlPath, Paths]));
end;


procedure EnvRemovePath(instlPath: string);
var
    Paths: string;
    P, Offset, DelimLen: Integer;
begin
    { Skip if registry entry not exists }
    if not RegQueryStringValue(HKEY_CURRENT_USER, EnvironmentKey, 'Path', Paths) then
        exit;

    { Skip if string not found in path }
    DelimLen := 1;     { Length(';') }
    P := Pos(';' + Uppercase(instlPath) + ';', ';' + Uppercase(Paths) + ';');
    if P = 0 then
    begin
        { perhaps instlPath lives in Paths, but terminated by '\;' }
        DelimLen := 2; { Length('\;') }
        P := Pos(';' + Uppercase(instlPath) + '\;', ';' + Uppercase(Paths) + ';');
        if P = 0 then exit;
    end;

    { Decide where to start string subset in Delete() operation. }
    if P = 1 then
        Offset := 0
    else
        Offset := 1;
    { Update path variable }
    Delete(Paths, P - Offset, Length(instlPath) + DelimLen);

    { Overwrite path environment variable }
    if RegWriteStringValue(HKEY_CURRENT_USER, EnvironmentKey, 'Path', Paths)
    then Log(Format('The [%s] removed from PATH: [%s]', [instlPath, Paths]))
    else Log(Format('Error while removing the [%s] from PATH: [%s]', [instlPath, Paths]));
end;
